I already have the following functions:
- generate_grid_graph(num_rows: int, num_columns: int) -> nx.Graph
- is_clique(graph: nx.Graph, vertex set: Set[int]) -> bool
- is_separator(graph: nx.Graph, vertex set: Set[int]) -> bool
- is_minimal_separator(graph: nx.Graph, vertex set: Set[int]) -> bool
- get_missing_edges_in_neighborhood(graph: nx.Graph, vertex: int) -> Set[Tuple[int, int]]
- get_missing_edges(graph: nx.Graph, vertex set: Set[int]) -> Set[Tuple[int, int]]
- is_clique_minimal_separator(graph: nx.Graph, vertex set: Set[int]) -> bool
- is_simplicial(graph: nx.Graph, vertex: int) -> bool
- is_almost_clique(graph: nx.Graph, vertex set: Set[int]) -> bool
- clique_minimal_separator_decomposition(graph: nx.Graph) -> List[Set[int]]
- is_almost_simplicial(graph: nx.Graph, vertex: int) -> bool

And NetworkX module in Python provides the following:
- graph.degree(vertex) -> int (the degree of a vertex)
- list(graph.neighbors(vertex)) -> list (the neighbours of a vertex)
- graph.subgraph(vertex set) -> graph (the subgraph induced by a set of vertices)
- list(nx.find_cliques(graph.subgraph(vertex_set))) -> list (the cliques of a subgraph)
- is_separator(graph, vertex_set) -> bool (whether a vertex set is a separator of a graph)
- nx.node_connectivity(graph) -> int (the vertex-connectivity of a graph)
- nx.number_connected_components(graph) -> int (the number of connected components of a graph)
- graph.remove_nodes_from(vertex_set) -> None (removes a set of vertices from a graph)
- nx.number_connected_components(graph) -> int (the number of connected components of a graph)

To construct a minimum chordal triangulation of a simple and undirected graph, we can reduce an input graph using the algorithm below:
```
Algorithm 1
Input: Graph `G`
Output: Set of added edges `F`, set of connected components (subgraphs) `processed`

Let `As` = [`G`] 
Let `processed` = []
Let `F` = []

While `As` has at least 1 element:
	Let `A_i` be an element from `As`
	For every vertex `v` in `A_i`:
		Let `N(v)` be the neighborhood of `v` in `A_i`
		For every non-clique vertex set `S` in `N(v)`:
			If `S` is a separator and is missing 1 edge, add the missing edge to `A_i` and `F`
	
	For every vertex `v` in `A_i`:
		If `v` is simplicial, eliminate it (remove the vertex, no need to add any edges)
		Else if `v` is almost simplicial and the size of the neighborhood of `v` is equal to the vertex connectivity of `A_i`, add every missing edge in the neighborhood of `v` to `A_i` and `F`, then remove `v` form `A_i`.
	
	Let `L_i` be the list of vertex sets returned by calling `clique_minimal_separator_decomposition` with `A_i`.

	Let `G_i` = []
	For each vertex set `L` in `L_i`:
		Let `G` be the graph induced on `L` (constructed by calling `A_i`.subgraph(`L`))
		Add `G` to `G_i`

	If `G_i` has one element, add it to `processed`
	Otherwise, add all the elements of `G_i` to `As`

Return `F` and `processed`
```

Definitions used:
Separator: A set of vertices whose removal disconnects the graph
Minimal separator: A separator that is not a subset of another separator
Clique minimal separator: A minimal separator that is a clique
Simplicial vertex: A vertex whose neighborhood is a clique
Almost clique: A vertex set that contains a vertex such that its removal makes the rest of the set a clique
Almost simplicial vertex: A vertex whose neighborhood is an almost clique
Clique minimal separator decomposition: A decomposition of a graph into a set of atoms. This can be done by finding a clique minimal separator S and then recursively decomposing the subgraphs (C\cup S) for each connected component C of G\setminus S. The atoms are maximally connected components after this decomposition (they don't contain any clique minimal separators).

def reduce_graph(G: nx.Graph) -> Tuple[Set[Tuple[int, int]], List[nx.Graph]]:
The graphs I am working with are grids. The vertex names are integers. Can you write me a function called `reduce_graph` that implements algorithm 1? Please add docstrings, to this function, and type annotations (as much as you can). Please also add comments to the code highlighting which step of the algorithm each part of the function is doing.