# Graph representation
I am working on treewidth and minimum triangulation (chordal supergraphs with the minimum number of added edges) of simple undirected graphs. More specifically grid graphs on 5 rows and 5 or more columns (5xn grids). Here is my graph representation: Vertices have labels (represented in string) and the vertex with label 10203 is on row 2 and column 3. Similarly, 11114 is the vertex on row 11 and column 14 (the left-most character is always 1).

# Hypothesis to prove
I know that 5xn grids have a treewidth of 5. I want to test my hypothesis that all 5xn grids have a minimum triangulation where the treewidth of this triangulation is 5 (all of the largest cliques in this triangulation have 6 vertices).

# Definition of elimination ordering
To do this, I have constructed minimum elimination orderings of these graphs. We can construct a minimum triangulation H from a minimum elimination ordering with the following algorithm:
- Let G_0 = G (the input graph)
- We can construct G_i from G_{i-1} by first adding all the missing edges between the neighbors of the ith vertex in G_{i-1} and then removing the ith vertex from G_{i-1}.
- By this definition, G_n is an empty graph
The triangulation H is constructed from G by the addition of all the edges during the minimum elimination ordering. 

# Definition of madj
Given an elimination ordering, the higher adjacency of a vertex v, written madj(v) (where v is the ith vertex in the elimination ordering of graph G) is the neighborhood of v_i in the graph G_{i-1}.
madj(v) can also be calculated from the input graph G: madj(v) contains every vertex u in G such that there exists a path from u to v (or an edge) that contains vertices that come earlier in the elimination ordering than both u and v.
For example, take a 5x5 grid where we first eliminate 10505 and then 10405. Then madj(10405) = {10305, 10404, 10504} and madj(10505) = {10405, 10504}.

# Existing theorems (where madj of a vertex has only 2 vertices)
I already have a theorem that tells me how to safely eliminate vertices where their madj has 2 vertices so that the resulting elimination ordering still results in a minimum triangulation. So for example in a 5x5 grid, I know that I can safely eliminate 10505 first.

# Existing theorems (where madj of a vertex has 3 vertices with other restrictions)
I also have a theorem that tells me I can eliminate v at step i where madj(v) had n vertices if G_{i_{i-1}} has the vertex connectivity of n and madj(v) is an almost clique in G_{i-{i-1}} (almost clique means that there exists a vertex u in madj(v) such that madj(v)-u is a clique). For example, after 10101, 10105, 10501 and 10505 are eliminated in the 5x5 grid, the resulting graph becomes 3-connected and I know I can eliminate 10405 next because its madj is {10305, 10404, 10504} and {10404, 10504} is a clique in G_{i_{i-1}} so {10305, 10404, 10504} is an almost clique.

# Question
But I don't know anything else beyond this rule for vertices that have madj with 3 or more vertices. I have come up with elimination orderings in 5xn grids for 5>=n>=14 such that the resulting triangulation has a treewidth of 5. I will show them to you and want you to observe patterns in the elimination orderings and help me come up with a rule/hypothesis about the elimination of vertices with madj of 3 or more. Is that OK?

# Second prompt
I have attached a file "elims.py" where the keys are the sizes of the grids as a string e.g. "5x5" and the values are the elimination orderings as a string for example "10101 10105 10501 10505 10102 10104 10201 10205 10401 10405 10502 10504 10404 10402 10303 10204 10503 10403 10305 10304 10302 10301 10203 10202 10103" (vertices are space separated).
Can you find any patterns in the elimination of vertices that have madj of 3 or more? Skip vertices where madj is less than 3 and the last 5 vertices (the graph becomes a clique at that point).


# Simpler task

## Graph representation
I am working on treewidth and minimum triangulation (chordal supergraphs with the minimum number of added edges) of simple undirected graphs. More specifically grid graphs on 5 rows and 5 or more columns (5xn grids). Here is my graph representation: Vertices have labels (represented in string) and the vertex with label 10203 is on row 2 and column 3. Similarly, 11114 is the vertex on row 11 and column 14 (the left-most character is always 1).

## Definition of elimination ordering
To do this, I have constructed minimum elimination orderings of these graphs. We can construct a minimum triangulation H from a minimum elimination ordering with the following algorithm:
- Let G_0 = G (the input graph)
- We can construct G_i from G_{i-1} by first adding all the missing edges between the neighbors of the ith vertex in G_{i-1} and then removing the ith vertex from G_{i-1}.
- By this definition, G_n is an empty graph
The triangulation H is constructed from G by the addition of all the edges during the minimum elimination ordering. 

## Definition of madj
Given an elimination ordering, the higher adjacency of a vertex v, written madj(v) (where v is the ith vertex in the elimination ordering of graph G) is the neighborhood of v_i in the graph G_{i-1}.
madj(v) can also be calculated from the input graph G: madj(v) contains every vertex u in G such that there exists a path from u to v (or an edge) that contains vertices that come earlier in the elimination ordering than both u and v.
For example, take a 5x5 grid where we first eliminate 10505 and then 10405. Then madj(10405) = {10305, 10404, 10504} and madj(10505) = {10405, 10504}.

## Question:
I have a dictionary of graph sizes as the string keys (e.g., "5x5") and the elimination ordering values as strings (e.g., "10101 10105 10501 10505 10102 10104 10201 10205 10401 10405 10502 10504 10404 10402 10303 10204 10503 10403 10305 10304 10302 10301 10203 10202 10103").
Can you write me a function that takes a graph size as a string parameter and its elimination ordering as a string and outputs a list of tuples where the first element is the vertex label and the second element is a set of vertices in its madj. You can use Python's NetworkX library and the helper functions below:
```py
def compute_madj(
        vertex: str,
        ordering: List[str],
        graph: nx.Graph
) -> Set[str]:
    """
    Compute the madj of a vertex based on the current ordering and graph.

    Parameters:
    - vertex (str): The vertex whose madj is to be computed.
    - ordering (List[str]): The current ordering of the vertices.
    - graph (nx.Graph): The graph.

    Returns:
    - Set[str]: The madj of the vertex.
    """
    # Get the position of the vertex in the ordering
    position: int = ordering.index(vertex)

    # Initialize madj
    madj: Set[str] = set()

    # Iterate over all vertices that come after the current vertex in the ordering
    for later_vertex in ordering[position+1:]:
        # Check if there's a path from later_vertex to vertex that only goes through vertices
        # earlier in the ordering than both vertex and later_vertex
        if nx.has_path(graph, later_vertex, vertex):
            madj.add(later_vertex)
    return madj

def generate_grid_graph(num_rows: int, num_columns: int) -> nx.Graph:
    """
    Generate a grid graph with custom vertex labels.

    Parameters:
    - num_rows (int): The number of rows in the grid.
    - num_columns (int): The number of columns in the grid.

    Returns:
    - nx.Graph: The generated graph with custom vertex labels.

    The vertex labels are of the form 1rrcc, where rr is the row number and cc is the column number.
    """

    # Generate the original grid graph
    grid = nx.grid_2d_graph(num_rows, num_columns)

    # Generate a mapping from old labels (tuples) to new labels (strings).
    # Add a leading '1' to each label to avoid leading zeros.
    # The new labels are of the form 1rrcc, where rr is the row number and cc is the column number.
    mapping = {(r, c): f"1{r+1:02}{c+1:02}" for r in range(num_rows)
               for c in range(num_columns)}

    # Create a new graph with nodes relabeled
    relabeled_graph = nx.relabel_nodes(grid, mapping)

    return relabeled_graph
```